Antonio Rojas (2):
      Fix build of Qt.labs.location QML plugin
      Fix appendChildNode() call

Antti Kokko (1):
      Add changes file for Qt 5.15.2

Edward Welbourne (1):
      Use QLocale::NorwegianBokmal rather than Norwegian

Jani Heikkinen (2):
      Bump version
      Bump version

Michal Klocek (2):
      Fix compilation for no opengl builds
      Blacklist ReviewModel::test_reset

Piotr Mikolajczyk (2):
      Fix crash when showing Map QML comp. for 2nd+ time
      Simpler fix to crashing Qml Map appearing 2nd+ time

Tadej Novak (1):
      Allow removal of layers and sources created using parameters in MapboxGL

Tarja Sundqvist (3):
      Update commercial license headers
      Revert "Update commercial license headers"
      Merge remote-tracking branch 'origin/tqtc/lts-5.15.4' into tqtc/lts-5.15-opensource

Vyacheslav Koscheev (1):
      Android: fix Location properties

diff --git a/src/location/configure.json b/src/location/configure.json
index 62ab0297..d1e623a1 100644
--- a/src/location/configure.json
+++ b/src/location/configure.json
@@ -9,6 +9,7 @@
             "label": "Qt.labs.location experimental QML plugin",
             "purpose": "Provides experimental QtLocation QML types",
             "section": "Location",
+            "condition": "features.opengl",
             "output": [ "privateFeature" ]
         },
         "geoservices_osm": {
diff --git a/src/location/declarativemaps/qdeclarativecirclemapitem.cpp b/src/location/declarativemaps/qdeclarativecirclemapitem.cpp
index 841c29a8..955de2c0 100644
--- a/src/location/declarativemaps/qdeclarativecirclemapitem.cpp
+++ b/src/location/declarativemaps/qdeclarativecirclemapitem.cpp
@@ -446,6 +446,7 @@ void QDeclarativeCircleMapItem::updatePolish()
 */
 void QDeclarativeCircleMapItem::possiblySwitchBackend(const QGeoCoordinate &oldCenter, qreal oldRadius, const QGeoCoordinate &newCenter, qreal newRadius)
 {
+#if QT_CONFIG(opengl)
     if (m_backend != QDeclarativeCircleMapItem::OpenGL)
         return;
 
@@ -459,6 +460,9 @@ void QDeclarativeCircleMapItem::possiblySwitchBackend(const QGeoCoordinate &oldC
         QScopedPointer<QDeclarativeCircleMapItemPrivate> d(static_cast<QDeclarativeCircleMapItemPrivate *>(new QDeclarativeCircleMapItemPrivateOpenGL(*this)));
         m_d.swap(d);
     }
+#else
+    return;
+#endif
 }
 
 /*!
@@ -534,9 +538,17 @@ void QDeclarativeCircleMapItem::setBackend(QDeclarativeCircleMapItem::Backend b)
     if (b == m_backend)
         return;
     m_backend = b;
-    QScopedPointer<QDeclarativeCircleMapItemPrivate> d((m_backend == Software)
-                                                        ? static_cast<QDeclarativeCircleMapItemPrivate *>(new QDeclarativeCircleMapItemPrivateCPU(*this))
-                                                        : static_cast<QDeclarativeCircleMapItemPrivate * >(new QDeclarativeCircleMapItemPrivateOpenGL(*this)));
+    QScopedPointer<QDeclarativeCircleMapItemPrivate> d(
+            (m_backend == Software) ? static_cast<QDeclarativeCircleMapItemPrivate *>(
+                    new QDeclarativeCircleMapItemPrivateCPU(*this))
+#if QT_CONFIG(opengl)
+                                    : static_cast<QDeclarativeCircleMapItemPrivate *>(
+                                            new QDeclarativeCircleMapItemPrivateOpenGL(*this)));
+#else
+                                    : nullptr);
+    qFatal("Requested non software rendering backend, but source code is compiled wihtout opengl "
+           "support");
+#endif
     m_d.swap(d);
     m_d->onGeoGeometryChanged();
     emit backendChanged();
@@ -565,7 +577,9 @@ QDeclarativeCircleMapItemPrivate::~QDeclarativeCircleMapItemPrivate() {}
 
 QDeclarativeCircleMapItemPrivateCPU::~QDeclarativeCircleMapItemPrivateCPU() {}
 
+#if QT_CONFIG(opengl)
 QDeclarativeCircleMapItemPrivateOpenGL::~QDeclarativeCircleMapItemPrivateOpenGL() {}
+#endif
 
 bool QDeclarativeCircleMapItemPrivate::preserveCircleGeometry (QList<QDoubleVector2D> &path,
                                     const QGeoCoordinate &center, qreal distance, const QGeoProjectionWebMercator &p)
diff --git a/src/location/declarativemaps/qdeclarativecirclemapitem_p_p.h b/src/location/declarativemaps/qdeclarativecirclemapitem_p_p.h
index 4cf42173..dbe6c8bf 100644
--- a/src/location/declarativemaps/qdeclarativecirclemapitem_p_p.h
+++ b/src/location/declarativemaps/qdeclarativecirclemapitem_p_p.h
@@ -275,6 +275,7 @@ public:
     MapPolygonNode *m_node = nullptr;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativeCircleMapItemPrivateOpenGL: public QDeclarativeCircleMapItemPrivate
 {
 public:
@@ -443,6 +444,7 @@ public:
     MapPolygonNodeGL *m_node = nullptr;
     MapPolylineNodeOpenGLExtruded *m_polylinenode = nullptr;
 };
+#endif // QT_CONFIG(opengl)
 
 QT_END_NAMESPACE
 
diff --git a/src/location/declarativemaps/qdeclarativepolygonmapitem.cpp b/src/location/declarativemaps/qdeclarativepolygonmapitem.cpp
index fa6ee174..af4f55eb 100644
--- a/src/location/declarativemaps/qdeclarativepolygonmapitem.cpp
+++ b/src/location/declarativemaps/qdeclarativepolygonmapitem.cpp
@@ -334,6 +334,7 @@ void QGeoMapPolygonGeometry::updateScreenPoints(const QGeoMap &map, qreal stroke
         this->translate(QPointF(strokeWidth, strokeWidth));
 }
 
+#if QT_CONFIG(opengl)
 QGeoMapPolygonGeometryOpenGL::QGeoMapPolygonGeometryOpenGL(){
 }
 
@@ -344,6 +345,7 @@ void QGeoMapPolygonGeometryOpenGL::updateSourcePoints(const QGeoMap &map, const
         geopath.append(QWebMercator::mercatorToCoord(c));
     updateSourcePoints(map, geopath);
 }
+#endif
 
 // wrapPath always preserves the geometry
 // This one handles holes
@@ -452,6 +454,7 @@ static void cutPathEars(const QList<QDoubleVector2D> &wrappedPath,
         screenIndices << quint32(i);
 }
 
+#if QT_CONFIG(opengl)
 /*!
     \internal
 */
@@ -594,7 +597,7 @@ void QGeoMapPolygonGeometryOpenGL::updateQuickGeometry(const QGeoProjectionWebMe
     sourceBounds_.setWidth(brect.width());
     sourceBounds_.setHeight(brect.height());
 }
-
+#endif // QT_CONFIG(opengl)
 /*
  * QDeclarativePolygonMapItem Private Implementations
  */
@@ -603,8 +606,9 @@ QDeclarativePolygonMapItemPrivate::~QDeclarativePolygonMapItemPrivate() {}
 
 QDeclarativePolygonMapItemPrivateCPU::~QDeclarativePolygonMapItemPrivateCPU() {}
 
+#if QT_CONFIG(opengl)
 QDeclarativePolygonMapItemPrivateOpenGL::~QDeclarativePolygonMapItemPrivateOpenGL() {}
-
+#endif
 /*
  * QDeclarativePolygonMapItem Implementation
  */
@@ -689,9 +693,17 @@ void QDeclarativePolygonMapItem::setBackend(QDeclarativePolygonMapItem::Backend
     if (b == m_backend)
         return;
     m_backend = b;
-    QScopedPointer<QDeclarativePolygonMapItemPrivate> d((m_backend == Software)
-                                                        ? static_cast<QDeclarativePolygonMapItemPrivate *>(new QDeclarativePolygonMapItemPrivateCPU(*this))
-                                                        : static_cast<QDeclarativePolygonMapItemPrivate * >(new QDeclarativePolygonMapItemPrivateOpenGL(*this)));
+    QScopedPointer<QDeclarativePolygonMapItemPrivate> d(
+            (m_backend == Software) ? static_cast<QDeclarativePolygonMapItemPrivate *>(
+                    new QDeclarativePolygonMapItemPrivateCPU(*this))
+#if QT_CONFIG(opengl)
+                                    : static_cast<QDeclarativePolygonMapItemPrivate *>(
+                                            new QDeclarativePolygonMapItemPrivateOpenGL(*this)));
+#else
+                                    : nullptr);
+    qFatal("Requested non software rendering backend, but source code is compiled wihtout opengl "
+           "support");
+#endif
     m_d.swap(d);
     m_d->onGeoGeometryChanged();
     emit backendChanged();
@@ -898,6 +910,7 @@ void QDeclarativePolygonMapItem::geometryChanged(const QRectF &newGeometry, cons
 
 //////////////////////////////////////////////////////////////////////
 
+#if QT_CONFIG(opengl)
 QSGMaterialShader *MapPolygonMaterial::createShader() const
 {
     return new MapPolygonShader();
@@ -916,6 +929,7 @@ QSGMaterialType *MapPolygonMaterial::type() const
     static QSGMaterialType type;
     return &type;
 }
+#endif
 
 MapPolygonNode::MapPolygonNode() :
     border_(new MapPolylineNode()),
@@ -967,6 +981,7 @@ void MapPolygonNode::update(const QColor &fillColor, const QColor &borderColor,
     }
 }
 
+#if QT_CONFIG(opengl)
 MapPolygonNodeGL::MapPolygonNodeGL() :
     //fill_material_(this),
     fill_material_(),
@@ -1052,5 +1067,5 @@ void MapPolygonShader::updateState(const QSGMaterialShader::RenderState &state,
     program()->setUniformValue(m_center_lowpart_id, vecCenter_lowpart);
     program()->setUniformValue(m_wrapOffset_id, float(newMaterial->wrapOffset()));
 }
-
+#endif // QT_CONFIG(opengl)
 QT_END_NAMESPACE
diff --git a/src/location/declarativemaps/qdeclarativepolygonmapitem_p_p.h b/src/location/declarativemaps/qdeclarativepolygonmapitem_p_p.h
index 8d566e69..5e75deb5 100644
--- a/src/location/declarativemaps/qdeclarativepolygonmapitem_p_p.h
+++ b/src/location/declarativemaps/qdeclarativepolygonmapitem_p_p.h
@@ -89,6 +89,7 @@ protected:
     bool assumeSimple_;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QGeoMapPolygonGeometryOpenGL : public QGeoMapItemGeometry
 {
 public:
@@ -197,6 +198,7 @@ private:
     int m_color_id;
     int m_wrapOffset_id;
 };
+#endif // QT_CONFIG(opengl)
 
 class Q_LOCATION_PRIVATE_EXPORT MapPolygonMaterial : public QSGFlatColorMaterial
 {
@@ -269,6 +271,7 @@ private:
     QSGGeometry geometry_;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT MapPolygonNodeGL : public MapItemGeometryNode
 {
 
@@ -284,6 +287,7 @@ public:
     MapPolygonMaterial fill_material_;
     QSGGeometry geometry_;
 };
+#endif // QT_CONFIG(opengl)
 
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativePolygonMapItemPrivate
 {
@@ -479,6 +483,7 @@ public:
     MapPolygonNode *m_node = nullptr;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativePolygonMapItemPrivateOpenGL: public QDeclarativePolygonMapItemPrivate
 {
 public:
@@ -662,6 +667,7 @@ public:
     MapPolygonNodeGL *m_node = nullptr;
     MapPolylineNodeOpenGLExtruded *m_polylinenode = nullptr;
 };
+#endif // QT_CONFIG(opengl)
 
 QT_END_NAMESPACE
 
diff --git a/src/location/declarativemaps/qdeclarativepolylinemapitem.cpp b/src/location/declarativemaps/qdeclarativepolylinemapitem.cpp
index d59704dc..83d253fd 100644
--- a/src/location/declarativemaps/qdeclarativepolylinemapitem.cpp
+++ b/src/location/declarativemaps/qdeclarativepolylinemapitem.cpp
@@ -769,6 +769,7 @@ bool QGeoMapPolylineGeometry::contains(const QPointF &point) const
     return false;
 }
 
+#if QT_CONFIG(opengl)
 void QGeoMapPolylineGeometryOpenGL::updateSourcePoints(const QGeoMap &map, const QGeoPolygon &poly)
 {
     if (!sourceDirty_)
@@ -921,6 +922,7 @@ void QGeoMapPolylineGeometryOpenGL::updateQuickGeometry(const QGeoProjectionWebM
     sourceBounds_.setWidth(brect.width() + strokeWidth);
     sourceBounds_.setHeight(brect.height() + strokeWidth);
 }
+#endif // QT_CONFIG(opengl)
 
 /*
  * QDeclarativePolygonMapItem Private Implementations
@@ -928,12 +930,13 @@ void QGeoMapPolylineGeometryOpenGL::updateQuickGeometry(const QGeoProjectionWebM
 
 QDeclarativePolylineMapItemPrivate::~QDeclarativePolylineMapItemPrivate() {}
 
-
 QDeclarativePolylineMapItemPrivateCPU::~QDeclarativePolylineMapItemPrivateCPU() {}
 
+#if QT_CONFIG(opengl)
 QDeclarativePolylineMapItemPrivateOpenGLLineStrip::~QDeclarativePolylineMapItemPrivateOpenGLLineStrip() {}
 
 QDeclarativePolylineMapItemPrivateOpenGLExtruded::~QDeclarativePolylineMapItemPrivateOpenGLExtruded() {}
+#endif
 
 /*
  * QDeclarativePolygonMapItem Implementation
@@ -941,10 +944,12 @@ QDeclarativePolylineMapItemPrivateOpenGLExtruded::~QDeclarativePolylineMapItemPr
 
 struct PolylineBackendSelector
 {
+#if QT_CONFIG(opengl)
     PolylineBackendSelector()
     {
         backend = (qgetenv("QTLOCATION_OPENGL_ITEMS").toInt()) ? QDeclarativePolylineMapItem::OpenGLExtruded : QDeclarativePolylineMapItem::Software;
     }
+#endif
     QDeclarativePolylineMapItem::Backend backend = QDeclarativePolylineMapItem::Software;
 };
 
@@ -1236,11 +1241,22 @@ void QDeclarativePolylineMapItem::setBackend(QDeclarativePolylineMapItem::Backen
     if (b == m_backend)
         return;
     m_backend = b;
-    QScopedPointer<QDeclarativePolylineMapItemPrivate> d((m_backend == Software)
-                                                        ? static_cast<QDeclarativePolylineMapItemPrivate *>(new QDeclarativePolylineMapItemPrivateCPU(*this))
-                                                        : ((m_backend == OpenGLExtruded)
-                                                           ? static_cast<QDeclarativePolylineMapItemPrivate * >(new QDeclarativePolylineMapItemPrivateOpenGLExtruded(*this))
-                                                           : static_cast<QDeclarativePolylineMapItemPrivate * >(new QDeclarativePolylineMapItemPrivateOpenGLLineStrip(*this))));
+    QScopedPointer<QDeclarativePolylineMapItemPrivate> d(
+            (m_backend == Software)
+                    ? static_cast<QDeclarativePolylineMapItemPrivate *>(
+                            new QDeclarativePolylineMapItemPrivateCPU(*this))
+#if QT_CONFIG(opengl)
+                    : ((m_backend == OpenGLExtruded)
+                               ? static_cast<QDeclarativePolylineMapItemPrivate *>(
+                                       new QDeclarativePolylineMapItemPrivateOpenGLExtruded(*this))
+                               : static_cast<QDeclarativePolylineMapItemPrivate *>(
+                                       new QDeclarativePolylineMapItemPrivateOpenGLLineStrip(
+                                               *this))));
+#else
+                    : nullptr);
+    qFatal("Requested non software rendering backend, but source code is compiled wihtout opengl "
+           "support");
+#endif
     m_d.swap(d);
     m_d->onGeoGeometryChanged();
     emit backendChanged();
@@ -1477,6 +1493,7 @@ void MapPolylineNode::update(const QColor &fillColor,
     }
 }
 
+#if QT_CONFIG(opengl)
 MapPolylineNodeOpenGLLineStrip::MapPolylineNodeOpenGLLineStrip()
 : geometry_(QSGGeometry::defaultAttributes_Point2D(), 0)
 {
@@ -2080,5 +2097,6 @@ unsigned int QGeoMapItemLODGeometry::zoomForLOD(unsigned int zoom)
         return res;
     return res + 1; // give more resolution when closing in
 }
+#endif // QT_CONFIG(opengl)
 
 QT_END_NAMESPACE
diff --git a/src/location/declarativemaps/qdeclarativepolylinemapitem_p.h b/src/location/declarativemaps/qdeclarativepolylinemapitem_p.h
index 9cd20ea5..d3d0ebd6 100644
--- a/src/location/declarativemaps/qdeclarativepolylinemapitem_p.h
+++ b/src/location/declarativemaps/qdeclarativepolylinemapitem_p.h
@@ -97,8 +97,10 @@ class Q_LOCATION_PRIVATE_EXPORT QDeclarativePolylineMapItem : public QDeclarativ
 public:
     enum Backend {
         Software = 0,
+#if QT_CONFIG(opengl)
         OpenGLLineStrip = 1,
         OpenGLExtruded = 2,
+#endif
     };
 
     explicit QDeclarativePolylineMapItem(QQuickItem *parent = 0);
diff --git a/src/location/declarativemaps/qdeclarativepolylinemapitem_p_p.h b/src/location/declarativemaps/qdeclarativepolylinemapitem_p_p.h
index 2a921e29..e184391c 100644
--- a/src/location/declarativemaps/qdeclarativepolylinemapitem_p_p.h
+++ b/src/location/declarativemaps/qdeclarativepolylinemapitem_p_p.h
@@ -213,6 +213,7 @@ protected:
     QSGGeometry geometry_;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QGeoMapItemLODGeometry
 {
 public:
@@ -566,6 +567,7 @@ protected:
     MapPolylineMaterialExtruded fill_material_;
     QSGGeometry m_geometryTriangulating;
 };
+#endif // QT_CONFIG(opengl)
 
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativePolylineMapItemPrivate
 {
@@ -720,6 +722,7 @@ public:
     MapPolylineNode *m_node = nullptr;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativePolylineMapItemPrivateOpenGLLineStrip: public QDeclarativePolylineMapItemPrivate
 {
 public:
@@ -884,7 +887,7 @@ public:
 
     MapPolylineNodeOpenGLExtruded *m_nodeTri = nullptr;
 };
-
+#endif // QT_CONFIG(opengl)
 QT_END_NAMESPACE
 
 #endif // QDECLARATIVEPOLYLINEMAPITEM_P_P_H
diff --git a/src/location/declarativemaps/qdeclarativerectanglemapitem.cpp b/src/location/declarativemaps/qdeclarativerectanglemapitem.cpp
index 74d2cc13..6192be08 100644
--- a/src/location/declarativemaps/qdeclarativerectanglemapitem.cpp
+++ b/src/location/declarativemaps/qdeclarativerectanglemapitem.cpp
@@ -185,9 +185,18 @@ void QDeclarativeRectangleMapItem::setBackend(QDeclarativeRectangleMapItem::Back
     if (b == m_backend)
         return;
     m_backend = b;
-    QScopedPointer<QDeclarativeRectangleMapItemPrivate> d((m_backend == Software)
-                                                        ? static_cast<QDeclarativeRectangleMapItemPrivate *>(new QDeclarativeRectangleMapItemPrivateCPU(*this))
-                                                        : static_cast<QDeclarativeRectangleMapItemPrivate * >(new QDeclarativeRectangleMapItemPrivateOpenGL(*this)));
+    QScopedPointer<QDeclarativeRectangleMapItemPrivate> d(
+            (m_backend == Software) ? static_cast<QDeclarativeRectangleMapItemPrivate *>(
+                    new QDeclarativeRectangleMapItemPrivateCPU(*this))
+#if QT_CONFIG(opengl)
+                                    : static_cast<QDeclarativeRectangleMapItemPrivate *>(
+                                            new QDeclarativeRectangleMapItemPrivateOpenGL(*this)));
+#else
+                                    : nullptr);
+    qFatal("Requested non software rendering backend, but source code is compiled wihtout opengl "
+           "support");
+#endif
+
     m_d.swap(d);
     m_d->onGeoGeometryChanged();
     emit backendChanged();
@@ -397,6 +406,8 @@ QDeclarativeRectangleMapItemPrivate::~QDeclarativeRectangleMapItemPrivate() {}
 
 QDeclarativeRectangleMapItemPrivateCPU::~QDeclarativeRectangleMapItemPrivateCPU() {}
 
+#if QT_CONFIG(opengl)
 QDeclarativeRectangleMapItemPrivateOpenGL::~QDeclarativeRectangleMapItemPrivateOpenGL() {}
+#endif
 
 QT_END_NAMESPACE
diff --git a/src/location/declarativemaps/qdeclarativerectanglemapitem_p_p.h b/src/location/declarativemaps/qdeclarativerectanglemapitem_p_p.h
index 65d2f618..f7ecd2a8 100644
--- a/src/location/declarativemaps/qdeclarativerectanglemapitem_p_p.h
+++ b/src/location/declarativemaps/qdeclarativerectanglemapitem_p_p.h
@@ -244,6 +244,7 @@ public:
     MapPolygonNode *m_node = nullptr;
 };
 
+#if QT_CONFIG(opengl)
 class Q_LOCATION_PRIVATE_EXPORT QDeclarativeRectangleMapItemPrivateOpenGL: public QDeclarativeRectangleMapItemPrivate
 {
 public:
@@ -410,6 +411,7 @@ public:
     MapPolygonNodeGL *m_node = nullptr;
     MapPolylineNodeOpenGLExtruded *m_polylinenode = nullptr;
 };
+#endif // QT_CONFIG(opengl)
 
 QT_END_NAMESPACE
 
diff --git a/src/location/labs/qsg/qgeomapobjectqsgsupport.cpp b/src/location/labs/qsg/qgeomapobjectqsgsupport.cpp
index 0e1df8f6..11e1466f 100644
--- a/src/location/labs/qsg/qgeomapobjectqsgsupport.cpp
+++ b/src/location/labs/qsg/qgeomapobjectqsgsupport.cpp
@@ -157,9 +157,14 @@ void QGeoMapObjectQSGSupport::updateMapObjects(QSGNode *root, QQuickWindow *wind
 {
     if (!root)
         return;
+
+    if (m_mapObjectsRootNode && !m_mapObjectsRootNode->parent())
+        root->appendChildNode(m_mapObjectsRootNode.get());
+
     if (!m_mapObjectsRootNode) {
-        m_mapObjectsRootNode = new QDeclarativePolygonMapItemPrivateOpenGL::RootNode();
-        root->appendChildNode(m_mapObjectsRootNode);
+        m_mapObjectsRootNode = std::make_unique<QDeclarativePolygonMapItemPrivateOpenGL::RootNode>();
+        root->appendChildNode(m_mapObjectsRootNode.get());
+        m_mapObjectsRootNode->setFlag(QSGNode::OwnedByParent, false);
     }
 
     m_mapObjectsRootNode->removeAllChildNodes();
@@ -184,7 +189,7 @@ void QGeoMapObjectQSGSupport::updateMapObjects(QSGNode *root, QQuickWindow *wind
         MapObject &mo = m_mapObjects[i];
         QQSGMapObject *sgo = mo.sgObject;
         QSGNode *oldNode = mo.qsgNode;
-        mo.qsgNode = sgo->updateMapObjectNode(oldNode, &mo.visibleNode, m_mapObjectsRootNode, window);
+        mo.qsgNode = sgo->updateMapObjectNode(oldNode, &mo.visibleNode, m_mapObjectsRootNode.get(), window);
         if (Q_UNLIKELY(!mo.qsgNode)) {
             qWarning() << "updateMapObjectNode for "<<mo.object->type() << " returned NULL";
         } else if (mo.visibleNode && (mo.visibleNode->visible() != mo.object->visible())) {
@@ -200,7 +205,7 @@ void QGeoMapObjectQSGSupport::updateMapObjects(QSGNode *root, QQuickWindow *wind
         QQSGMapObject *sgo = mo.sgObject;
         QSGNode *oldNode = mo.qsgNode;
         sgo->updateGeometry(); // or subtree will be blocked
-        mo.qsgNode = sgo->updateMapObjectNode(oldNode, &mo.visibleNode, m_mapObjectsRootNode, window);
+        mo.qsgNode = sgo->updateMapObjectNode(oldNode, &mo.visibleNode, m_mapObjectsRootNode.get(), window);
         if (mo.qsgNode) {
             if (mo.visibleNode && (mo.visibleNode->visible() != mo.object->visible())) {
                 mo.visibleNode->setVisible(mo.object->visible());
diff --git a/src/location/labs/qsg/qgeomapobjectqsgsupport_p.h b/src/location/labs/qsg/qgeomapobjectqsgsupport_p.h
index 1ec966fa..cbbc0969 100644
--- a/src/location/labs/qsg/qgeomapobjectqsgsupport_p.h
+++ b/src/location/labs/qsg/qgeomapobjectqsgsupport_p.h
@@ -59,6 +59,7 @@
 #include <QtLocation/private/qdeclarativepolylinemapitem_p.h>
 #include <QtLocation/private/qdeclarativepolygonmapitem_p_p.h>
 #include <QtCore/qpointer.h>
+#include <memory>
 
 QT_BEGIN_NAMESPACE
 struct Q_LOCATION_PRIVATE_EXPORT MapObject {
@@ -85,7 +86,7 @@ public:
     QList<MapObject> m_pendingMapObjects;
     QList<MapObject> m_removedMapObjects;
     QGeoMap *m_map = nullptr;
-    QDeclarativePolygonMapItemPrivateOpenGL::RootNode *m_mapObjectsRootNode = nullptr;
+    std::unique_ptr<QDeclarativePolygonMapItemPrivateOpenGL::RootNode> m_mapObjectsRootNode;
 };
 
 QT_END_NAMESPACE
diff --git a/src/location/location.pro b/src/location/location.pro
index b0e2c3f1..ae202718 100644
--- a/src/location/location.pro
+++ b/src/location/location.pro
@@ -39,7 +39,14 @@ include(maps/maps.pri)
 include(places/places.pri)
 include(declarativemaps/declarativemaps.pri)
 include(declarativeplaces/declarativeplaces.pri)
-qtConfig(location-labs-plugin):include(labs/labs.pri)
+qtConfig(location-labs-plugin) {
+   include(labs/labs.pri)
+} else {
+  # FIXME: this should be moved out of plugin source code, geojson is referenced from other places
+  # within codebase,however compilation of location-labs-plugin is optional
+  PRIVATE_HEADERS += labs/qgeojson_p.h
+  SOURCES += labs/qgeojson.cpp
+}
 
 HEADERS += $$PUBLIC_HEADERS $$PRIVATE_HEADERS
 
diff --git a/src/plugins/geoservices/itemsoverlay/qgeomapitemsoverlay.cpp b/src/plugins/geoservices/itemsoverlay/qgeomapitemsoverlay.cpp
index 1ebad08d..a7644383 100644
--- a/src/plugins/geoservices/itemsoverlay/qgeomapitemsoverlay.cpp
+++ b/src/plugins/geoservices/itemsoverlay/qgeomapitemsoverlay.cpp
@@ -103,6 +103,7 @@ QGeoMap::Capabilities QGeoMapItemsOverlay::capabilities() const
 bool QGeoMapItemsOverlay::createMapObjectImplementation(QGeoMapObject *obj)
 {
 #ifndef LOCATIONLABS
+    Q_UNUSED(obj);
     return false;
 #else
     Q_D(QGeoMapItemsOverlay);
@@ -132,7 +133,9 @@ QSGNode *QGeoMapItemsOverlay::updateSceneGraph(QSGNode *node, QQuickWindow *wind
 
 void QGeoMapItemsOverlay::removeMapObject(QGeoMapObject *obj)
 {
-#ifdef LOCATIONLABS
+#ifndef LOCATIONLABS
+    Q_UNUSED(obj);
+#else
     Q_D(QGeoMapItemsOverlay);
     d->removeMapObject(obj);
 #endif
@@ -169,7 +172,11 @@ QRectF QGeoMapItemsOverlayPrivate::visibleArea() const
 QGeoMapItemsOverlayPrivate::QGeoMapItemsOverlayPrivate(QGeoMappingManagerEngineItemsOverlay *engine, QGeoMapItemsOverlay *map)
     : QGeoMapPrivate(engine, new QGeoProjectionWebMercator)
 {
+#ifndef LOCATIONLABS
+    Q_UNUSED(map);
+#else
     m_qsgSupport.m_map = map;
+#endif
 }
 
 QGeoMapItemsOverlayPrivate::~QGeoMapItemsOverlayPrivate()
diff --git a/src/plugins/geoservices/mapboxgl/qgeomapmapboxgl.cpp b/src/plugins/geoservices/mapboxgl/qgeomapmapboxgl.cpp
index 9c088f2f..66763af3 100644
--- a/src/plugins/geoservices/mapboxgl/qgeomapmapboxgl.cpp
+++ b/src/plugins/geoservices/mapboxgl/qgeomapmapboxgl.cpp
@@ -193,6 +193,11 @@ void QGeoMapMapboxGLPrivate::removeParameter(QGeoMapParameter *param)
     Q_Q(QGeoMapMapboxGL);
 
     q->disconnect(param);
+
+    if (m_styleLoaded) {
+        m_styleChanges << QMapboxGLStyleChange::removeMapParameter(param);
+        emit q->sgNodeChanged();
+    }
 }
 
 QGeoMap::ItemTypes QGeoMapMapboxGLPrivate::supportedMapItemTypes() const
diff --git a/src/plugins/geoservices/mapboxgl/qmapboxglstylechange.cpp b/src/plugins/geoservices/mapboxgl/qmapboxglstylechange.cpp
index 6dc8ea70..483f8f6d 100644
--- a/src/plugins/geoservices/mapboxgl/qmapboxglstylechange.cpp
+++ b/src/plugins/geoservices/mapboxgl/qmapboxglstylechange.cpp
@@ -255,6 +255,35 @@ QList<QSharedPointer<QMapboxGLStyleChange>> QMapboxGLStyleChange::addMapItem(QDe
     return changes;
 }
 
+QList<QSharedPointer<QMapboxGLStyleChange>> QMapboxGLStyleChange::removeMapParameter(QGeoMapParameter *param)
+{
+    static const QStringList acceptedParameterTypes = QStringList()
+        << QStringLiteral("paint") << QStringLiteral("layout") << QStringLiteral("filter")
+        << QStringLiteral("layer") << QStringLiteral("source") << QStringLiteral("image");
+
+    QList<QSharedPointer<QMapboxGLStyleChange>> changes;
+
+    switch (acceptedParameterTypes.indexOf(param->type())) {
+    case -1:
+        qWarning() << "Invalid value for property 'type': " + param->type();
+        break;
+    case 0: // paint
+    case 1: // layout
+    case 2: // filter
+        break;
+    case 3: // layer
+        changes << QSharedPointer<QMapboxGLStyleChange>(new QMapboxGLStyleRemoveLayer(param->property("name").toString()));
+        break;
+    case 4: // source
+        changes << QSharedPointer<QMapboxGLStyleChange>(new QMapboxGLStyleRemoveSource(param->property("name").toString()));
+        break;
+    case 5: // image
+        break;
+    }
+
+    return changes;
+}
+
 QList<QSharedPointer<QMapboxGLStyleChange>> QMapboxGLStyleChange::removeMapItem(QDeclarativeGeoMapItemBase *item)
 {
     QList<QSharedPointer<QMapboxGLStyleChange>> changes;
diff --git a/src/plugins/geoservices/mapboxgl/qmapboxglstylechange_p.h b/src/plugins/geoservices/mapboxgl/qmapboxglstylechange_p.h
index fd5b9af4..9a8f50ea 100644
--- a/src/plugins/geoservices/mapboxgl/qmapboxglstylechange_p.h
+++ b/src/plugins/geoservices/mapboxgl/qmapboxglstylechange_p.h
@@ -59,6 +59,7 @@ public:
 
     static QList<QSharedPointer<QMapboxGLStyleChange>> addMapParameter(QGeoMapParameter *);
     static QList<QSharedPointer<QMapboxGLStyleChange>> addMapItem(QDeclarativeGeoMapItemBase *, const QString &before);
+    static QList<QSharedPointer<QMapboxGLStyleChange>> removeMapParameter(QGeoMapParameter *);
     static QList<QSharedPointer<QMapboxGLStyleChange>> removeMapItem(QDeclarativeGeoMapItemBase *);
 
     virtual void apply(QMapboxGL *map) = 0;
diff --git a/src/plugins/position/android/src/jnipositioning.cpp b/src/plugins/position/android/src/jnipositioning.cpp
index 05b25d98..a9fe6ae7 100644
--- a/src/plugins/position/android/src/jnipositioning.cpp
+++ b/src/plugins/position/android/src/jnipositioning.cpp
@@ -223,7 +223,10 @@ namespace AndroidPositioning {
         if (attributeExists) {
             mid = getCachedMethodID(jniEnv, thisClass, "getAltitude", "()D");
             jdouble value = jniEnv->CallDoubleMethod(location, mid);
-            coordinate.setAltitude(value);
+            if (value != 0.0)
+            {
+                coordinate.setAltitude(value);
+            }
         }
 
         info.setCoordinate(coordinate);
@@ -239,7 +242,10 @@ namespace AndroidPositioning {
         if (attributeExists) {
             mid = getCachedMethodID(jniEnv, thisClass, "getAccuracy", "()F");
             jfloat accuracy = jniEnv->CallFloatMethod(location, mid);
-            info.setAttribute(QGeoPositionInfo::HorizontalAccuracy, qreal(accuracy));
+            if (accuracy != 0.0)
+            {
+                info.setAttribute(QGeoPositionInfo::HorizontalAccuracy, qreal(accuracy));
+            }
         }
 
         //vertical accuracy
@@ -250,7 +256,10 @@ namespace AndroidPositioning {
                 mid = getCachedMethodID(jniEnv, thisClass, "getVerticalAccuracyMeters", "()F");
                 if (mid) {
                     jfloat accuracy = jniEnv->CallFloatMethod(location, mid);
-                    info.setAttribute(QGeoPositionInfo::VerticalAccuracy, qreal(accuracy));
+                    if (accuracy != 0.0)
+                    {
+                        info.setAttribute(QGeoPositionInfo::VerticalAccuracy, qreal(accuracy));
+                    }
                 }
             }
         }
@@ -264,7 +273,10 @@ namespace AndroidPositioning {
         if (attributeExists) {
             mid = getCachedMethodID(jniEnv, thisClass, "getSpeed", "()F");
             jfloat speed = jniEnv->CallFloatMethod(location, mid);
-            info.setAttribute(QGeoPositionInfo::GroundSpeed, qreal(speed));
+            if (speed != 0)
+            {
+                info.setAttribute(QGeoPositionInfo::GroundSpeed, qreal(speed));
+            }
         }
 
         //bearing
@@ -273,7 +285,10 @@ namespace AndroidPositioning {
         if (attributeExists) {
             mid = getCachedMethodID(jniEnv, thisClass, "getBearing", "()F");
             jfloat bearing = jniEnv->CallFloatMethod(location, mid);
-            info.setAttribute(QGeoPositionInfo::Direction, qreal(bearing));
+            if (bearing != 0.0)
+            {
+                info.setAttribute(QGeoPositionInfo::Direction, qreal(bearing));
+            }
         }
 
         jniEnv->DeleteLocalRef(thisClass);
diff --git a/tests/auto/declarative_core/BLACKLIST b/tests/auto/declarative_core/BLACKLIST
index 99b4d786..428216ae 100644
--- a/tests/auto/declarative_core/BLACKLIST
+++ b/tests/auto/declarative_core/BLACKLIST
@@ -4,3 +4,7 @@ osx
 # QTBUG-59074  flaky test
 [CoordinateAnimation::test_east_direction_coordinate_animation]
 osx
+# QTBUG-90244  flaky test
+[ReviewModel::test_reset]
+windows
+
diff --git a/tests/auto/qplacemanager/tst_qplacemanager.cpp b/tests/auto/qplacemanager/tst_qplacemanager.cpp
index 2cb035cd..919be2d9 100644
--- a/tests/auto/qplacemanager/tst_qplacemanager.cpp
+++ b/tests/auto/qplacemanager/tst_qplacemanager.cpp
@@ -108,7 +108,7 @@ void tst_QPlaceManager::testLocales()
     QCOMPARE(placeManager->locales().count(), 1);
     QCOMPARE(placeManager->locales().at(0), QLocale());
 
-    QLocale locale(QLocale::Norwegian, QLocale::Norway);
+    QLocale locale(QLocale::NorwegianBokmal, QLocale::Norway);
     placeManager->setLocale(locale);
 
     QCOMPARE(placeManager->locales().at(0), locale);
diff --git a/tests/auto/qplacemanager_unsupported/tst_qplacemanager_unsupported.cpp b/tests/auto/qplacemanager_unsupported/tst_qplacemanager_unsupported.cpp
index 98a9dd31..58300904 100644
--- a/tests/auto/qplacemanager_unsupported/tst_qplacemanager_unsupported.cpp
+++ b/tests/auto/qplacemanager_unsupported/tst_qplacemanager_unsupported.cpp
@@ -120,7 +120,7 @@ void tst_QPlaceManagerUnsupported::testLocales()
 {
     QVERIFY(m_manager->locales().isEmpty());
 
-    QLocale locale(QLocale::Norwegian, QLocale::Norway);
+    QLocale locale(QLocale::NorwegianBokmal, QLocale::Norway);
     m_manager->setLocale(locale);
 
     QVERIFY(m_manager->locales().isEmpty());
